#include<math.h>
#define tolerance 0.0001
#define n 32;
float A[n+2][n+2], B[n+2][n+2], change, maxchange; 
int i, j; 
int stream higher[n+1], stream lower[n+1];
int count, numiter; 
spinlock Arrival, Departure; 
boolean globaldone;
float seqstart, parstart;
spinlock L;

void LocalBarrier(int i) {
	int dummy;
	if (i > 1) send(higher[i-1],1); /*send to Process i-1*/
	if (i < n) {
		send(lower[i+1],1);  /*send to Process i+1*/
		recv(higher[i],dummy); /*receive from Process i-1*/
	}
	if (i > 1) recv(lower[i],dummy); /*receive from Process i+1*/
}

boolean Aggregate(boolean mydone)  
{ 
	boolean result; /*Arrival Phase -Count the processes arriving*/ 
	Lock(Arrival); 
	count++;  
	globaldone= globaldone&& mydone; /*aggregation*/ 
	
	
	if (count < n) Unlock(Arrival); /*continue Arrival Phase*/ 
	else Unlock(Departure); /*end Arrival Phase*/ 
	
	/*Departure Phase -Count the processes leaving*/ 
	Lock(Departure); 
	count--;  
	result = globaldone; /*return “done”flag*/ 
	if (count > 0)	Unlock(Departure); /*continue Departure Phase*/ 
	else 
	{ 
		Unlock(Arrival);	/*terminate Departure Phase*/ 
		globaldone= true;	/*reset for new Aggregation*/ 
	} 
	return(result); 
}
                       
main( )  
{ 
	count = 0; /*Initialize “count”and spinlocks*/ 
	Unlock(Arrival);  
	Lock(Departure); 
	globaldone= false;  /*Initialize global flag*/ 

	/* array initialization */   
	for (i = 1; i <= n; i++)     
		for (j = 1; j <= n; j++)       
			A[i][j] = 0;   
	for (i = 0; i < n+2; i++) 
	{    
		A[i][0] = i; 
		A[0][i] = i;    
		A[n+1][i] = 33-i; 
		A[i][n+1] = 33-i;   
	}
	
	B = A; 
	seqstart = seqtime();
	parstart = clock();
	numiter=0;
	forall i = 1 to n do  
	{ 
		/*Create the processes*/ 
		float change, maxchange; 
		boolean done; 
		int j,k, temp1, temp2;
		do{ 
			if(i%2==1)
			{
				temp1=1;
				temp2=2;
			}
			else
			{
				temp1=2;
				temp2=1;
			}
			maxchange= 0; 
			for(j=temp1; j<=n; j+=2)
			{
				B[i][j] = (A[i-1][j] + A[i+1][j] + A[i][j-1] + A[i][j+1]) / 4;
				change = fabs( B[i][j] -A[i][j] ); 
				if (change > maxchange) maxchange= change; 
			}
			LocalBarrier(i);
			A[i] = B[i];
			LocalBarrier(i);
			for(j=temp2; j<=n; j+=2)
			{
				B[i][j] = (A[i-1][j] + A[i+1][j] + A[i][j-1] + A[i][j+1]) / 4;
				change = fabs( B[i][j] -A[i][j] ); 
				if (change > maxchange) maxchange= change; 
			}
			LocalBarrier(i);
			A[i] = B[i];
			LocalBarrier(i);
			done = Aggregate(maxchange<tolerance); 
			
			Lock(L);
			numiter++;
			Unlock(L);
		}while (!done); /*iterate until global termination*/ 
	} 
	cout.precision(5);
	cout << "Seqtime = " << seqtime() - seqstart << endl;
	cout << "Partime = " << clock() - parstart << endl;
	cout << "Speedup = " << (seqtime() - seqstart) / (clock() - parstart) << endl;
	cout << "Efficiency = " << (seqtime() - seqstart) / (clock() - parstart) / 33 << endl;
	cout << "Par Time Per Iteration = " << (clock() - parstart) / numiter << endl;
	
	/*
	for (i = 0; i < n+2; i++) 
	{
		for (j = 0; j < n+2; j++) 
		{
			cout << A[i][j];
		}
		cout << endl;
	}*/
} 